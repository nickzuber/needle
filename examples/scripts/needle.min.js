/*!
 // node-needle v0.1.9 | MIT 
 // Copyright (c) 2016 Nick Zuber <zuber.nicholas@gmail.com>
 */
!function t(e,i,n){function r(s,h){if(!i[s]){if(!e[s]){var a="function"==typeof require&&require;if(!h&&a)return a(s,!0);if(o)return o(s,!0);throw new Error("Cannot find module '"+s+"'")}var u=i[s]={exports:{}};e[s][0].call(u.exports,function(t){var i=e[s][1][t];return r(i?i:t)},u,u.exports,t,e,i,n)}return i[s].exports}for(var o="function"==typeof require&&require,s=0;s<n.length;s++)r(n[s]);return r}({1:[function(t,e,i){"use strict";const n=t("./lib/singlyLinkedList.js"),r=t("./lib/queue.js"),o=t("./lib/stack.js"),s=t("./lib/doublyLinkedList.js"),h=t("./lib/binaryHeap.js"),a=t("./lib/binarySearchTree.js"),u=t("./lib/hashmap.js"),f=t("./lib/sortedArray.js"),p=t("./lib/rollingHash.js"),d=t("./lib/bitArray.js"),l=t("./lib/karyTree.js"),y={};y.SinglyLinkedList=n,y.Queue=r,y.Stack=o,y.DoublyLinkedList=s,y.BinaryHeap=h,y.BinarySearchTree=a,y.Hashmap=u,y.SortedArray=f,y.RollingHash=p,y.BitArray=d,y.KaryTree=l,i=e.exports=y,"undefined"!=typeof window&&(window.Needle=y)},{"./lib/binaryHeap.js":2,"./lib/binarySearchTree.js":3,"./lib/bitArray.js":4,"./lib/doublyLinkedList.js":5,"./lib/hashmap.js":6,"./lib/karyTree.js":7,"./lib/queue.js":12,"./lib/rollingHash.js":13,"./lib/singlyLinkedList.js":14,"./lib/sortedArray.js":15,"./lib/stack.js":16}],2:[function(t,e,i){"use strict";function n(t,e){return t<e}function r(t,e,i){if("function"!=typeof i)throw new TypeError("Compare must be a function in BinaryHeap");if("undefined"==typeof t&&"undefined"!=typeof e||"undefined"!=typeof t&&"undefined"==typeof e)return!1;if("undefined"!=typeof t&&"undefined"!=typeof e)return i(t,e);throw new TypeError("Comparing two undefined elements in BinaryHeap. Please report this to https://github.com/nickzuber/needle/issues")}Array.prototype.swap=function(t,e){var i=this[t];return this[t]=this[e],this[e]=i,this};const o=function(t){this.heap=[null],this.compare=n,"function"==typeof t&&(this.compare=t)};o.prototype.peek=function(){return this.heap[1]},o.prototype.getParent=function(t){return this.heap[Math.floor(t/2)]},o.prototype.getLeftChild=function(t){return this.heap[2*t]},o.prototype.getRightChild=function(t){return this.heap[2*t+1]},o.prototype.size=function(){return this.heap.length-1},o.prototype.insert=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for BinaryHeap.insert");if(this.heap.push(t),!(this.heap.length<=2))for(var e=this.heap.length-1;e>1;)r(this.heap[e],this.heap[Math.floor(e/2)],this.compare)&&this.heap.swap(e,Math.floor(e/2)),e=Math.floor(e/2)},o.prototype["delete"]=function(t){if("number"==typeof t?++t:t=1,"number"!=typeof t)throw new TypeError("Expected a number as argument in BinaryHeap.delete");if(t<0||t>=this.heap.length)throw new Error("Index out of bounds in BinaryHeap.delete");if(this.heap.length<=1)throw new Error("Attempted to remove min element from an empty heap in BinaryHeap.delete");if(2===this.heap.length)return void this.heap.pop();if(this.heap[t]=this.heap.pop(),2===this.heap.length);else if(3===this.heap.length){var t=1;r(this.heap[2*t],this.heap[t],this.compare)&&this.heap.swap(t,2*t)}else for(var e=0,t=1;r(this.heap[2*t],this.heap[t],this.compare)||r(this.heap[2*t+1],this.heap[t],this.compare);){var i;if(i=r(this.heap[2*t],this.heap[2*t+1],this.compare)||"undefined"==typeof this.heap[2*t+1]?2*t:2*t+1,this.heap.swap(t,i),t=i,++e,e>1e3)throw new Error("Timeout error in BinaryHeap.delete. Please report this to https://github.com/nickzuber/needle/issues")}},o.prototype._heapify=function(t){var e=2*t,i=e+1,n=t;this.heap.length;e<this.heap.length&&r(this.heap[e],this.heap[n],this.compare)&&(n=e),i<this.heap.length&&r(this.heap[i],this.heap[n],this.compare)&&(n=i),n!=t&&(this.heap.swap(t,n),this._heapify(n)),"undefined"==typeof this.heap[2*t]&&"undefined"==typeof this.heap[2*t+1]||(r(this.heap[2*t],this.heap[t],this.compare)||r(this.heap[2*t+1],this.heap[t],this.compare))&&(r(this.heap[2*t],this.heap[2*t+1],this.compare)?(this.heap.swap(t,2*t),this._heapify(2*t)):(this.heap.swap(t,2*t+1),this._heapify(2*t+1)))},o.prototype.heapify=function(t){this.heap=t,this.heap.unshift(null),console.log(this.heap);for(var e=Math.floor(t.length-1);e>=1;--e)this._heapify(e);console.log(this.heap)},e.exports=o},{}],3:[function(t,e,i){"use strict";function n(t,e){return t<e}function r(t,e,i){if("function"!=typeof i)throw new TypeError("Compare must be a function in BinarySearchTree");if("undefined"==typeof t&&"undefined"!=typeof e||"undefined"!=typeof t&&"undefined"==typeof e)return!1;if("undefined"!=typeof t&&"undefined"!=typeof e)return i(t,e);throw new TypeError("Comparing two undefined elements in BinarySearchTree. Please report this to https://github.com/nickzuber/needle/issues")}const o=t("./nodes/bidirectional_tree_node.js"),s=function(t){this.root=null,this.compare=n,"function"==typeof t&&(this.compare=t)};s.prototype.hasRight=function(t){return null!==t.right},s.prototype.hasLeft=function(t){return null!==t.left},s.prototype.isLeaf=function(t){return null===t.left&&null===t.right},s.prototype.emptySubtree=function(t){null!==t&&(this.emptySubtree(t.left),t.left=null,this.emptySubtree(t.right),t.right=null,t=null)},s.prototype.emptyTree=function(){if(null===this.root)throw new Error("Attempted to empty a nulled tree in BinarySearchTree.emptyTree");this.emptySubtree(this.root),this.root=null},s.prototype.heightSubtree=function(t){return null===t?0:1+Math.max(this.heightSubtree(t.left),this.heightSubtree(t.right))},s.prototype.numNodesSubtree=function(t){return null===t?0:1+(this.numNodesSubtree(t.left)+this.numNodesSubtree(t.right))},s.prototype.numLeavesSubtree=function(t){return null===t?0:null===t.left&&null===t.right?1:this.numLeavesSubtree(t.left)+this.numLeavesSubtree(t.right)},s.prototype.insert=function(t,e){if(null===e)throw new Error("Attemped to insert node in a nulled location in BinarySearchTree.insert");return null===this.root?void(this.root=new o(t)):("undefined"==typeof e&&(e=this.root),void(r(t,e.data,this.compare)?this.hasLeft(e)?this.insert(t,e.left):e.left=new o(t):this.hasRight(e)?this.insert(t,e.right):e.right=new o(t)))},s.prototype.search=function(t,e){return null!==e&&("undefined"==typeof e&&(e=this.root),JSON.stringify(t)===JSON.stringify(e.data)?e:r(t,e.data,this.compare)?this.search(t,e.left):this.search(t,e.right))},e.exports=s},{"./nodes/bidirectional_tree_node.js":9}],4:[function(t,e,i){"use strict";var n=function(t){if("number"==typeof t)return t;"string"!=typeof t&&(t=JSON.stringify(t));var e=0;return t.split("").map(function(t){e+=t.charCodeAt(0)}),e};const r=32,o=function(t){if(this.data=[],"undefined"!=typeof t){"number"!=typeof t&&(t=n(t));for(var e=0;e<Math.ceil(t/r);++e)this.data.push(0)}};o.prototype.set=function(t,e){if(t<0||t>=this.data.length*r)throw new Error("Index out of bounds in BitArray.set");var i=Math.floor(t++/r);e?this.data[i]|=1<<r-t:this.data[i]&=~(1<<r-t)},o.prototype.get=function(t){if(t<0||t>=this.data.length*r)throw new Error("Index out of bounds in BitArray.get");var e=Math.floor(t++/r),i=this.data[e];return i>>r-t&1},o.prototype.size=function(){return this.data.length*r},o.prototype.resize=function(t){if("number"!=typeof bitarray)throw new TypeError("");return this.data.length*r},o.prototype.complement=function(t){"undefined"==typeof t?t=this:t instanceof o||(t=new o(t));var e=new o;return t.data.map(function(t){e.data.push(~t)}),e},o.prototype.union=function(t){if("undefined"==typeof t)throw new Error("Undefined bitarray argument in BitArray.union");if(!(t instanceof o))throw new TypeError("Invalid argument: expected BitArray as an argument in BitArray.union");if(t.size()!==this.size())throw new Error("BitArrays must be of same size to resolve a union in BitArray.union");for(var e=new o,i=0;i<this.data.length;++i)e.data.push(this.data[i]|t.data[i]);return e},o.prototype.intersection=function(t){if("undefined"==typeof t)throw new Error("Undefined bitarray argument in BitArray.union");if(!(t instanceof o))throw new TypeError("Invalid argument: expected BitArray as an argument in BitArray.union");if(t.size()!==this.size())throw new Error("BitArrays must be of same size to resolve a union in BitArray.union");for(var e=new o,i=0;i<this.data.length;++i)e.data.push(this.data[i]&t.data[i]);return e},o.prototype.difference=function(t){if("undefined"==typeof t)throw new Error("Undefined bitarray argument in BitArray.union");if(!(t instanceof o))throw new TypeError("Invalid argument: expected BitArray as an argument in BitArray.union");if(t.size()!==this.size())throw new Error("BitArrays must be of same size to resolve a union in BitArray.union");for(var e=new o,i=0;i<this.data.length;++i)e.data.push(this.data[i]&~t.data[i]);return e},o.prototype.toString=function(){var t="";return this.data.map(function(e){for(var i=0;i<r;i++)t+=String(e>>>31),e<<=1;t.split("").reverse().join("")}),t},e.exports=o},{}],5:[function(t,e,i){"use strict";const n=t("./nodes/bidirectional_node.js"),r=function(t){this.head,this.tail,this.size,"undefined"!=typeof t?(this.head=new n(t),this.tail=this.head,this.size=1):(this.head=null,this.tail=null,this.size=0)};r.prototype.insertFront=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for DoublyLinkedList.insertFront");var e=new n(t);if(null===this.head&&null===this.tail)this.head=e,this.tail=this.head;else{if(null===this.head||null===this.tail)throw new Error("Unsynced head and tail in an Doubly Linked List. Please report this to https://github.com/nickzuber/needle/issues");var i=this.head;i.prev=e,this.head=e,this.head.next=i,this.head.prev=null}++this.size},r.prototype.insertNth=function(t,e){if("undefined"==typeof e||"undefined"==typeof t)throw new Error("Too few arguments for DoublyLinkedList.insertNth");if("number"!=typeof t)throw new TypeError("Invalid argument for DoublyLinkedList.insertNth");if(t<0||t>=this.size&&0!==t)throw new Error("Index out of bounds on DoublyLinkedList.insertNth");if(0===t)return void this.insertFront(e);if(null===this.head)return!1;if(t===this.size-1)return void this.insertBack(e);for(var i=new n(e),r=this.head,o=1;o<t;++o)r=r.next;var s=r.next;r.next=i,s.prev=i,i.prev=r,i.next=s,++this.size},r.prototype.insertAfter=function(t,e){if("undefined"==typeof e||"undefined"==typeof t)throw new Error("Too few arguments for DoublyLinkedList.insertAfter");if(null===this.head)return!1;var i,r,o=new n(e),s=this.head,h=!1;if(r="object"==typeof t?JSON.stringify(t):t,i="object"==typeof s.data?JSON.stringify(s.data):s.data,JSON.stringify(this.tail.data)===JSON.stringify(t))return this.insertBack(e),!0;for(;null!==s;){if(i="object"==typeof s.data?JSON.stringify(s.data):s.data,i===r){h=!0;break}s=s.next}if(h){var a=s.next;return s.next=o,a.prev=o,o.prev=s,o.next=a,++this.size,!0}return!1},r.prototype.insertBack=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for DoublyLinkedList.insert");var e=new n(t);null===this.head?(this.head=e,this.tail=this.head):(e.next=null,e.prev=this.tail,this.tail.next=e,this.tail=e),++this.size},r.prototype.remove=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for DoublyLinkedList.remove");if(this.size<=0)throw new Error("Attempted to remove from an empty DoublyLinkedList");if(1===this.size)return this.head=null,this.tail=null,void(this.size=0);if(null===this.head&&this.size>0)throw new Error("Null head in an unemptied list. Please report this to https://github.com/nickzuber/needle/issues");var e,i,n=this.head,r=!1;if(i="object"==typeof t?JSON.stringify(t):t,e="object"==typeof n.data?JSON.stringify(n.data):n.data,JSON.stringify(this.head.data)===JSON.stringify(t))return this.head=n.next,this.head.prev=null,n=null,--this.size,!0;if(JSON.stringify(this.tail.data)===JSON.stringify(t))return n=this.tail,this.tail=n.prev,this.tail.next=null,n=null,--this.size,!0;for(n=n.next;null!==n;){if(e="object"==typeof n.data?JSON.stringify(n.data):n.data,e===i){r=!0;var o=n.prev;o.next=n.next,n.next.prev=o,n=null,--this.size;break}n=n.next}return r},r.prototype.removeNth=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for DoublyLinkedList.removeNth");if("number"!=typeof t)throw new TypeError("Invalid argument for DoublyLinkedList.removeNth");if(t<0||t>=this.size)throw new Error("Index out of bounds on DoublyLinkedList.removeNth: "+t);if(1===this.size)return this.head=null,this.tail=null,void(this.size=0);var e=this.head;if(0===t)return this.head=e.next,this.head.prev=null,e=null,void--this.size;if(t===this.size-1)return e=this.tail,this.tail=e.prev,this.tail.next=null,e=null,--this.size,!0;e=e.next;for(var i=1;i<t;++i)e=e.next;var n=e.prev;n.next=e.next,e.next.prev=n,e=null,--this.size},r.prototype.find=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for DoublyLinkedList.find");if(this.size<=0)throw new Error("Attempted to find a node from an empty DoublyLinkedList");if(null===this.head&&this.size>0)throw new Error("Null head in an unemptied list. Please report this to https://github.com/nickzuber/needle/issues");for(var e=this.head,i=!1;null!==e;){if(JSON.stringify(e.data)===JSON.stringify(t)){i=!0;break}e=e.next}return!!i&&e},r.prototype.findNth=function(t){if("undefined"==typeof t)throw new TypeError("Too few arguments for DoublyLinkedList.findNth");if("number"!=typeof t)throw new TypeError("Invalid argument for DoublyLinkedList.findNth");if(t<0||t>=this.size)throw new Error("Index out of bounds; attempted to find a node from a SinglyLinkedList that does not exist");if(null===this.head&&this.size>0)throw new Error("Null head in an unemptied list. Please report this to https://github.com/nickzuber/needle/issues");for(var e=this.head,i=0;i<t;++i)e=e.next;return e},e.exports=r},{"./nodes/bidirectional_node.js":8}],6:[function(t,e,i){"use strict";function n(t){return typeof t+"_"+JSON.stringify(t)}function r(t,e){for(var i=0,r=e.head,o=n(t),s=!1;null!==r;){if(n(r.data)===o){s=!0;break}++i,r=r.next}if(s)return void e.removeNth(i);throw new Error("Unable to find a non null entry within the internal linked list. Please report this to https://github.com/nickzuber/needle/issues")}const o=t("./doublyLinkedList.js"),s=function(){this.buckets={},this.current=void 0,this.list=new o};s.prototype.put=function(t,e){if("undefined"==typeof t||"undefined"==typeof e)throw new Error("Too few arguments in Hashmap.put");var i=n(t);void 0===this.buckets[i]&&this.list.insertBack(t),this.buckets[i]=e,void 0===this.current&&(this.current=this.list.head)},s.prototype.get=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in Hashmap.get");var e=n(t);return void 0!==this.buckets[e]&&this.buckets[e]},s.prototype["delete"]=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in Hashmap.delete");var e=n(t);return void 0!==this.buckets[e]&&(delete this.buckets[e],r(t,this.list),!0)},s.prototype.next=function(){if(this.list.size<=0)throw new Error("Cannot get next of an element when map is empty in Hashmap.next()");return this.current?this.current=this.current.next:0,this.current?this.current.data:null},s.prototype.iterator=function(){if(this.list.size<=0)throw new Error("Cannot get an iterator of a map when it's empty in Hashmap.iterator()");return this.current=this.list.head,this.current.data},s.prototype.size=function(){return this.list.size},e.exports=s},{"./doublyLinkedList.js":5}],7:[function(t,e,i){"use strict";const n=t("./nodes/multidirectional_tree_node.js"),r=function(t){this.root=new n(t)};r.prototype.isLeaf=function(t){if("undefined"==typeof t||null===t)throw new TypeError("Attempting to check the leaves of undefined node in KaryTree.isLeaf");return 0===t.children.length},r.prototype.emptySubtree=function(t){null!==t&&(t.children.map(function(t){this.emptySubtree(t),t=null}.bind(this)),t=null)},r.prototype.emptyTree=function(){if(null===this.root)throw new Error("Attempted to empty a nulled tree in KaryTree.emptyTree");this.emptySubtree(this.root),this.root=null},r.prototype.search=function(t,e){return null!==e&&("undefined"==typeof e&&(e=this.root),JSON.stringify(t)===JSON.stringify(e.data)?e:void e.children.map(function(e){search(t,e)}))},e.exports=r},{"./nodes/multidirectional_tree_node.js":10}],8:[function(t,e,i){"use strict";const n=function(t){this.data=t||void 0,this.next=null,this.prev=null};e.exports=n},{}],9:[function(t,e,i){"use strict";const n=function(t){this.data=t||void 0,this.right=null,this.left=null};e.exports=n},{}],10:[function(t,e,i){"use strict";const n=function(t){this.data=t||void 0,this.children=[]};n.prototype.appendChild=function(t){this.children.push(new n(t))},e.exports=n},{}],11:[function(t,e,i){"use strict";const n=function(t){this.data=t||void 0,this.next=null};e.exports=n},{}],12:[function(t,e,i){const n=t("./nodes/unidirectional_node.js"),r=function(t){this.front,this.back,this.size,"undefined"!=typeof t?(this.front=new n(t),this.back=this.front,this.front.next=this.back,this.back.next=null,this.size=1):(this.front=null,this.back=null,this.size=0)};r.prototype.enqueue=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in Queue.enqueue");var e=new n(t);if(null===this.front&&null===this.back)this.front=e,this.back=this.front,this.front.next=this.back,this.back.next=null,++this.size;else{if(null===this.front||null===this.back)throw new Error("Either front or back is not set in an a queue at once. Please report this to https://github.com/nickzuber/needle/issues");this.back.next=e,this.back=e,++this.size}},r.prototype.dequeue=function(){if(0===this.size)throw new Error("Attempted to dequeue from empty queue in Queue.enqueue");var t=this.front.next;this.front=t,--this.size},e.exports=r},{"./nodes/unidirectional_node.js":11}],13:[function(t,e,i){"use strict";var n=function(t,e){var i=r(t,e);if(1!==i)throw new Error("Modular base is not prime and inverse is not guarenteed in RollingHash.modInverse\n"+e);return o(t,e-2,e)},r=function(t,e){return 0===t?e:r(e%t,t)},o=function(t,e,i){if(e=parseInt(e),0===e)return 1;var n=o(t,e/2,i)%i;return n=n*n%i,e%2===0?n:t*n%i};String.prototype.ascii=function(){var t="";if(this.length>0)for(var e=0;e<this.length;++e)t+=""+this.charCodeAt(e);return t.length>0?parseInt(t):void 0};const s=2147483647,h=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in RollingHash constructor");if("number"!=typeof t)throw new TypeError("Invalid argument; expected a number in RollingHash constructor");this.BASE=t,this.state=0,this.CACHE=1,this.BUFFER_SIZE=Math.log(t)*Math.LOG10E+1|0,this.INVERSE_BASE=n(this.BASE,s)%s,this.OFFSET_IF_NEGATIVE=s*this.BASE};h.prototype.hash=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in RollingHash.hash");if(!parseInt(Math.pow(this.BASE,t.length-1)))throw new Error('Integer overflow while trying to hash "'+t+'" in RollingHash.hash\nThis hashing window is too large\nIf this issue is breaking to your program, please report this to https://github.com/nickzuber/needle/issues');var e=0;if("string"==typeof t)for(var i=0;i<t.length;++i)e+=t[i].ascii()%s*(Math.pow(this.BASE,t.length-1-i)%s)%s;else if(t.constructor===Array)for(var i=0;i<t.length;++i)e+=t[i]%s*(Math.pow(this.BASE,t.length-1-i)%s)%s;else{if("number"!=typeof t)throw new TypeError("Invalid argument; expecting number or string in RollingHash.hash\nk: "+t);e=t}return e%s},h.prototype.append=function(t){if("string"==typeof t&&(t=t.ascii()),!(t<this.BASE))throw new Error("Argument overflow in RollingHash.append\nn: "+t);this.CACHE=this.CACHE*this.BASE%s|0,this.state=(this.state*this.BASE+t)%s|0},h.prototype.skip=function(t){if("string"==typeof t&&(t=t.ascii()),!(t<this.BASE))throw new Error("Argument overflow in RollingHash.skip\no: "+t);this.CACHE=this.CACHE*this.INVERSE_BASE%s|0,this.state=(this.state-t*this.CACHE+this.OFFSET_IF_NEGATIVE)%s|0},h.prototype.slide=function(t,e){if("undefined"==typeof t||"undefined"==typeof e)throw new Error("Too few arguments in RollingHash.slide");if("string"==typeof t&&(t=t.ascii()),"string"==typeof e&&(e=e.ascii()),!(t<this.BASE&&e<this.BASE))throw new Error("One or more arguments overflowed in RollingHash.slide\no: "+t+"\nn:"+e);if("undefined"==typeof this.state)throw new Error("Attempted to slide an empty window in RollingHash.slide");return this.state=(this.state*this.BASE-t*this.CACHE+e+this.OFFSET_IF_NEGATIVE)%s,this.state},h.prototype.set=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in RollingHash.set");if("string"==typeof t||t.constructor===Array){this.state=0,this.CACHE=1;for(var e=0;e<t.length;++e)this.append(t[e]);return this.state}throw new TypeError("Invalid argument; expecting number or string in RollingHash.set")},e.exports=h},{}],14:[function(t,e,i){"use strict";const n=t("./nodes/unidirectional_node.js"),r=function(t){this.head,this.size,"undefined"!=typeof t?(this.head=new n(t),this.size=1):(this.head=null,this.size=0)};r.prototype.insertFront=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for SinglyLinkedList.insertFront");var e=new n(t);if(null===this.head)this.head=e;else{var i=this.head;this.head=e,this.head.next=i}++this.size},r.prototype.insertNth=function(t,e){if("undefined"==typeof e||"undefined"==typeof t)throw new Error("Too few arguments for SinglyLinkedList.insertNth");if("number"!=typeof t)throw new TypeError("Invalid argument for SinglyLinkedList.insertNth");if(t<0||t>=this.size&&0!==t)throw new Error("Index out of bounds on SinglyLinkedList.insertNth");if(0===t)return void this.insertFront(e);if(null===this.head)return!1;for(var i=new n(e),r=this.head,o=1;o<t;++o)r=r.next;var s=r.next;r.next=i,i.next=s,++this.size},r.prototype.insertAfter=function(t,e){if("undefined"==typeof e||"undefined"==typeof t)throw new Error("Too few arguments for SinglyLinkedList.insertAfter");if(null===this.head)return!1;var i,r,o=new n(e),s=this.head,h=!1;for(r="object"==typeof t?JSON.stringify(t):t;null!==s;){if(i="object"==typeof s.data?JSON.stringify(s.data):s.data,i===r){h=!0;break}s=s.next}if(h){var a=s.next;return s.next=o,o.next=a,++this.size,!0}return!1},r.prototype.insertBack=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for SinglyLinkedList.insertBack");var e=new n(t);if(null===this.head)this.head=e;else{for(var i=this.head;null!==i.next;)i=i.next;i.next=e}++this.size},r.prototype.remove=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for SinglyLinkedList.remove");if(this.size<=0)throw new Error("Attempted to remove from an empty SinglyLinkedList");if(1===this.size)return this.head=null,void(this.size=0);if(null===this.head&&this.size>0)throw new Error("Null head in an unemptied list. Please report this to https://github.com/nickzuber/needle/issues");var e,i,n=null,r=this.head,o=!1;if(i="object"==typeof t?JSON.stringify(t):t,e="object"==typeof r.data?JSON.stringify(r.data):r.data,e===i)return this.head=r.next,r=null,--this.size,!0;for(n=r,r=n.next;null!==r;){if(e="object"==typeof r.data?JSON.stringify(r.data):r.data,e===i){o=!0,n.next=r.next,r=null,--this.size;break}n=r,r=r.next}return o},r.prototype.removeNth=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for SinglyLinkedList.removeNth");if("number"!=typeof t)throw new TypeError("Invalid argument for SinglyLinkedList.removeNth");if(t<0||t>=this.size)throw new Error("Index out of bounds on SinglyLinkedList.removeNth: "+t);if(1===this.size)return this.head=null,void(this.size=0);var e=null,i=this.head;if(0===t)return this.head=i.next,i=null,void--this.size;e=i,i=i.next;for(var n=1;n<t;++n)e=i,i=i.next;e.next=i.next,i=null,--this.size},r.prototype.find=function(t){if("undefined"==typeof t)throw new Error("Too few arguments for SinglyLinkedList.find");if(this.size<=0)throw new Error("Attempted to find a node from an empty SinglyLinkedList");if(null===this.head&&this.size>0)throw new Error("Null head in an unemptied list. Please report this to https://github.com/nickzuber/needle/issues");for(var e=this.head,i=!1;null!==e;){if(JSON.stringify(e.data)===JSON.stringify(t)){i=!0;break}e=e.next}return!!i&&e},r.prototype.findNth=function(t){if("undefined"==typeof t)throw new TypeError("Too few arguments for SinglyLinkedList.findNth");if("number"!=typeof t)throw new TypeError("Invalid argument for SinglyLinkedList.findNth");if(t<0||t>=this.size)throw new Error("Index out of bounds; attempted to find a node from a SinglyLinkedList that does not exist");if(null===this.head&&this.size>0)throw new Error("Null head in an unemptied list. Please report this to https://github.com/nickzuber/needle/issues");for(var e=this.head,i=0;i<t;++i)e=e.next;return e},e.exports=r},{"./nodes/unidirectional_node.js":11}],15:[function(t,e,i){"use strict";function n(t,e){return t<e}function r(t,e){var i=t,n=e;return"object"==typeof t&&(i=JSON.stringify(t)),"object"==typeof e&&(n=JSON.stringify(e)),i===n}function o(t,e,i){if("function"!=typeof i)throw new TypeError("Compare must be a function in SortedArray");if("undefined"==typeof t&&"undefined"!=typeof e||"undefined"!=typeof t&&"undefined"==typeof e)return!1;if("undefined"!=typeof t&&"undefined"!=typeof e)return i(t,e);throw new TypeError("Comparing two undefined elements in SortedArray. Please report this to https://github.com/nickzuber/needle/issues")}const s=function(t){this.elements=[],this.compare=n,"function"==typeof t&&(this.compare=t)};s.prototype.insert=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in SortedArray.push");if(0===this.elements.length)return void this.elements.push(t);if(o(t,this.elements[0],this.compare))return void this.elements.unshift(t);for(var e=0,i=this.elements.length,n=Math.floor(e+(i-e)/2);Math.abs(i-e)>1&&!r(t,this.elements[n]);)n=Math.floor(e+(i-e)/2),o(this.elements[n],t,this.compare)?e=n:i=n;o(t,this.elements[n],this.compare)?this.elements.splice(n,0,t):this.elements.splice(n+1,0,t)},s.prototype["delete"]=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in SortedArray.delete");if(0===this.elements.length)return!1;for(var e=0,i=this.elements.length,n=Math.floor(e+(i-e)/2);i>=e;){if(n=Math.floor(e+(i-e)/2),r(t,this.elements[n]))return this.elements.splice(n,1),!0;o(this.elements[n],t,this.compare)?e=n+1:i=n-1}return!1},s.prototype.get=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in SortedArray.get");if(0==typeof t)throw new Error("Invalid argument; expected a number in SortedArray.get");return this.elements[t]},s.prototype.size=function(){return this.elements.length},s.prototype.toString=function(){var t,e="";for(t=0;t<this.elements.length;++t)e+=this.elements[t]+",";return this.elements.length>0?e.slice(0,-1):e},e.exports=s},{}],16:[function(t,e,i){"use strict";const n=t("./nodes/unidirectional_node.js"),r=function(t){this.top,this.size,"undefined"!=typeof t?(this.top=new n(t),this.size=1):(this.top=null,this.size=0)};r.prototype.peek=function(){return this.top},r.prototype.push=function(t){if("undefined"==typeof t)throw new Error("Too few arguments in Stack.push");var e=new n(t),i=this.top;this.top=e,this.top.next=i,++this.size},r.prototype.pop=function(){if(0===this.size)throw new Error("Attempted to remove from empty stack in Stack.pop");var t=this.top.next,e=this.top;return this.top=t,--this.size,e},e.exports=r},{"./nodes/unidirectional_node.js":11}]},{},[1]);